#!/usr/bin/python
# -*- coding: utf-8 -*-

# TODO: verify case sensitivity in generated bytes from string

import sys
import os

# arguments
VERBOSE = False
DEBUG = False
WARN_ALL = False
WARN_EQU = False # include already done
WARN_STR = False # \x00 in a string
WARN_LAB = False # a label is missing
IFNAME = None
OFNAME = None
DFNAME = None    # debug (verbose listing) filename
NB_COLS = 16

VERSION = "0.99"
COMMENT_TAG = ";"
EMPTY_STR = ""
KEYWORD_INCLUDE = ".include"
CHAR_SPACE =' '
CHAR_EOL = chr(0)
CHAR_QUOTE = '"'
CHAR_ANTISLASH = "\\"
CHAR_UNDERSCORE = "_"

APP_NAME = os.path.splitext(os.path.basename(sys.argv[0]))[0]

KEYWORD_STRING = ".string"
KEYWORD_CH_ARRAY = ".ch_array"
PRECOMP_KEYWORDS = (KEYWORD_STRING, KEYWORD_CH_ARRAY)
KEYWORD_MAIN = "main"
KEYWORD_IRQ = "irq"
KEYWORD_NMI = "nmi"
KEYWORD_SOURCE_END = "source_end"
REQUIRED_LABELS = (KEYWORD_MAIN, KEYWORD_IRQ, KEYWORD_NMI,KEYWORD_SOURCE_END)

FIRST_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_"
OTHER_CHAR = FIRST_CHAR + "0123456789"
NO_LABEL_FIRST_CHAR = " ;"

def write(text):
    sys.stdout.write(str(text))
    
def writeln(text):
    write(text)
    write("\n")

def printLink(message, line=None):
    if line != None:
        writeln('File "%s", line %d, %s'%(line.getFname(), line.getNum(), message))
        writeln(line.getText())
    
def printWarning(message, line=None):
    if line != None:
        writeln('File "%s", line %d, warning : %s'%(line.getFname(), line.getNum(), message))
        writeln(line.getText())
    else:
        writeln('Warning : %s'%(message))
    
def printError(message, line=None):
    if DEBUG:
        # the goal is to trig an error, then it's possible to follow the white rabbit
        1/0
    writeln('File "%s", line %d, error : %s'%(line.getFname(), line.getNum(), message))
    writeln(line.getText())
    sys.exit(1)

def getFileLines(fp):
    return [line.rstrip() for line in fp.readlines()]
    
def labelIsOk(label):
    if not len(label):
        return False
    if not label[0] in FIRST_CHAR:
        return False
    if label == CHAR_UNDERSCORE:
        return False
    for car in label[1:]:
        if not car in OTHER_CHAR:
            return False
    return True

def XX__removeComment(text):
    otext = EMPTY_STR
    if text.startswith(CHAR_SPACE):
        # no labelo, no problemo!
        return "%s %s"%(COMMENT_TAG, text)
    else:
        # there is a label :(
        space_found = False
        for car in text:
            if not space_found:
                if car == CHAR_SPACE:
                    otext += " %s "%COMMENT_TAG
                    space_found = True
            else:
                otext += car
    return otext
    
def removeComment(text):
    otext = EMPTY_STR
    out_str = 1
    in_str = 2
    mode = out_str
    for position, car in enumerate(text):
        if mode == out_str:
            if car == CHAR_QUOTE:
                otext += car
                mode = in_str
            elif car == COMMENT_TAG:
                return otext.rstrip()
            else:
                otext += car
        elif mode == in_str:
            if car == CHAR_QUOTE:
                otext += car
                mode = out_str
            else:
                otext += car
        else:
            printError("string not closed!")
    return otext
    
def getLabel(line, lower=True):
    text = removeComment(line.getText())
    if text != None:
        if len(text):
            if text[0] not in NO_LABEL_FIRST_CHAR:
                word = text.split()[0]
                if lower:
                    word = word.lower()
                if not labelIsOk(word):
                    printError("label \"%s\" incorrect"%word, line)
                return word
    return None

def extractWord(text, word_number, lower=True):
    if text.startswith(CHAR_SPACE):
        text = ".%s"%text
        if not word_number:
            return None
    text = removeComment(text)
    words = text.split()
    if word_number < len(words):
        word = words[word_number]
        if lower:
            word = word.lower()
        return word

def commentLine(text):
    otext = EMPTY_STR
    if text.startswith(COMMENT_TAG):
        # no labelo, no problemo!
        return text
    elif text.startswith(CHAR_SPACE):
        # no labelo, no problemo!
        return "%s%s"%(COMMENT_TAG, text)
    else:
        # there is a label :(
        space_found = False
        for car in text:
            if not space_found:
                if car == CHAR_SPACE:
                    otext += " %s "%COMMENT_TAG
                    space_found = True
                else:
                    otext += car
            else:
                otext += car
    return otext

def XX__commentLine(text):
    if text.startswith(COMMENT_TAG):
        # no labelo, no problemo!
        return text
    elif text.startswith(CHAR_SPACE):
        # no labelo, no problemo!
        return "%s%s"%(COMMENT_TAG, text)
    else:
        # don't comment all the line if it begins with a label
        found = False
        ret_text = EMPTY_STR
        for car in text:
            if found:
                ret_text += car
            else:
                if not car in (CHAR_SPACE, COMMENT_TAG):
                    ret_text += car
                else:
                    if car == COMMENT_TAG:
                        ret_text +=" %s "%COMMENT_TAG
                        found = True
        return ret_text

class SOURCE_LINE():
    def __init__(self, fname, text, num):
        assert type(fname) == str
        assert type(text) == str
        assert type(num) == int
        self.__num = num
        self.__text = text
        self.__fname = os.path.basename(fname)

    def getFname(self):
        return self.__fname

    def getText(self):
        return self.__text

    def setText(self, text):
        self.__text = text

    def getNum(self):
        return self.__num
        
    def __str__(self):
        return "%-40s %s\n"%("%s#%d"%(self.__fname, self.__num), self.__text)

class SOURCE_FILE():
    
    def __init__(self, fname=None):
        self.__fname = fname
        self.__lines = []
        self.__fnames = []
        self.__line_num = 1
        self.__labels = {}
        if not os.path.isfile(fname):
            printError("file \"%s\" not found"%inc_fname, SOURCE_LINE(fname, CHAR_SPACE.join(sys.argv), 0))
        self.parseFile(fname)
    
        # some labels are mandatory to build a ROM
        for label in REQUIRED_LABELS:
            if not label in self.__labels:
                if WARN_LAB:
                    printWarning("label %s not found"%label)

    def parseFile(self, fname):
        self.__fnames.append(fname)
        with open(fname, "r") as fp:
            lines = getFileLines(fp)
            for num, text in enumerate(lines):
                self.parseLine(fname, text, num)
                
    def parseLine(self, fname, text, num):
        word1 = extractWord(text, 1)
        if word1 == KEYWORD_INCLUDE :
            # keyword ".include" is detected, let's include the new file
            self.addLabel(SOURCE_LINE(fname, text, num + 1))
            line = SOURCE_LINE(fname, commentLine(text), num + 1)
            inc_fname = extractWord(text, 2, lower=False)
            if not self.isFileAlreadyIncluded(inc_fname):
                if not os.path.isfile(inc_fname):
                    printError("file \"%s\" not found"%inc_fname, SOURCE_LINE(fname, text, num + 1))
                self.__lines.append(line)
                # recursivity, seriously? :)
                self.parseFile(inc_fname)
                self.addPrecompilerLine("%s   End of inclusion of file %s"%(COMMENT_TAG, inc_fname))
            else:
                if WARN_EQU:
                    printWarning('file "%s" already included'%inc_fname, SOURCE_LINE(fname, text, num + 1))

        elif word1 in PRECOMP_KEYWORDS:
            self.addLabel(SOURCE_LINE(fname, text, num + 1))
            #a precompiler's keyword is detected, let's add some code
            writeln("%s\n%s\n"%(text, commentLine(text)))
            line = SOURCE_LINE(fname, commentLine(text), num + 1)                    
            self.__lines.append(line)
            
            if word1 == KEYWORD_STRING:
                self.addString(text, word1, SOURCE_LINE(fname, text, num + 1), oel=True)
            elif word1 == KEYWORD_CH_ARRAY:
                self.addString(text, word1, SOURCE_LINE(fname, text, num + 1), oel=False)
            
        else:
            self.addLabel(SOURCE_LINE(fname, text, num + 1))
            # nothing special, let's add this "regular" line
            self.__lines.append(SOURCE_LINE(fname, text, num + 1))


    def addString(self, text, key_word, line, oel=True):
        position = text.lower().find(key_word)
        start = position + len(key_word) + 1
        # checking if keyword is not in the label's location
        try:
            while text[start] == CHAR_SPACE:
                start += 1
        except:
            printError("missing data", line)
        # extracting & evaluating the string
        try:
            btext = eval(text[start:])
        except:
            printError("data mismatch, perhaps a comment (not allowed on %s line)"%key_word, line)
        
        # setting difference between string and ch_array (no end of line)
        if oel:
            if chr(0) in btext:
                if WARN_STR:
                    printWarning("there is a \\x00 (enf of string) in this line:", line)
            btext += CHAR_EOL
        
        self.buildMatrix( btext)

    def buildMatrix(self, text):

        # lets build the matrix
        position = 0
        last = len(text) - 1

        words = []
        for position, car in enumerate(text):
            byte = ord(text[position])
            if position % NB_COLS == 0:
                string_txt = "    .byte "
                
            words.append("$%02x"%byte)
            
            if (position % NB_COLS) == (NB_COLS - 1):
                string_txt += ", ".join(words)
                self.addPrecompilerLine(string_txt)
                words = []
                
        if len(words):
            string_txt += ", ".join(words)
            self.addPrecompilerLine(string_txt)

    def getNextPrecompLineNum(self):
        ret_val = self.__line_num
        self.__line_num += 1
        return ret_val

    def addPrecompilerLine(self, text):
        line = SOURCE_LINE("<precompiler>", text, self.getNextPrecompLineNum())
        self.__lines.append(line)

    def isFileAlreadyIncluded(self, fname):
        return fname in self.__fnames

    def isLabelFree(self, label):
        return not label in self.__labels.keys()

    def addLabel(self, line):
        label = getLabel(line)
        if label != None:
            if not self.isLabelFree(label):
                printLink("label previous declaration :", self.getLabelLine(label))
                printError("label %s already defined!"%label, line)
            else:
                self.__labels[label] = line

    def getLabelLine(self, label):
        return self.__labels[label]

    def getLabels(self):
        labels = self.__labels.keys()
        labels.sort()
        return labels
        
    def printLabels(self):
        keys = self.__labels.keys()
        keys.sort()
        for key in keys:
            line = self.__labels[key]
            writeln("%-16s %-16s %3d %s"%(key, line.getFname(), line.getNum(), line.getText()))

    def getOutputSource(self):
        text = EMPTY_STR
        for line in self.__lines:
            text += line.getText() + "\n"
        return text
                        
    def saveOutputSource(self, fname):
        #~ text = self.getOutputSource()
        open(fname, "w").write(self.getOutputSource())
                        
    def __str__(self):
        text= EMPTY_STR
        for line in self.__lines:
            text += line.__str__()
        return text
        
    def saveDebug(self, fname):
        fp = open(fname, "w")
        fp.write(self.__str__())
        fp.close()

def checkNextParameter(index, label):
    if index < len(sys.argv) -1:
        arg = sys.argv[index + 1]
        if not arg.startswith("-"):
            return arg
    #~ raise Exception("bad or missing argument for %s !"%label)
    printError("bad or missing argument for %s !"%label, SOURCE_LINE(sys.argv[0], CHAR_SPACE.join(sys.argv), 0))

def checkNextValue(index, label):
    text = checkNextParameter(index, label)
    try:
        value = int(text)
    except:
        printError("bad or missing hex value for %s !"%label, SOURCE_LINE(sys.argv[0], CHAR_SPACE.join(sys.argv), 0))

    return value
    
def chekFile(fname):
    if not os.path.isfile(fname):
        printError("file \"%s\" not found"%fname, SOURCE_LINE(sys.argv[0], CHAR_SPACE.join(sys.argv), 0))

def parseArguments():
    global VERBOSE
    global DEBUG
    global WARN_ALL
    global WARN_EQU
    global MODEL
    global IFNAME
    global OFNAME
    global DFNAME
    global NB_COLS
    global WARN_STR
    global WARN_LAB
    
    index = 1
    ignored_paremeters = []
    processed = []
    
    while 1:
        arg = sys.argv[index]
        if arg in processed:
            raise Exception("argument \"%s\" already processed!\n"%arg)
        else:
            processed.append(arg)
            
        if arg == "-ifname":
            IFNAME = checkNextParameter(index, arg)
            chekFile(IFNAME)
            index += 1
        elif arg == "-ofname":
            OFNAME = checkNextParameter(index, arg)
            chekFile(OFNAME)
            index += 1
        elif arg == "-dfname":
            DFNAME = checkNextParameter(index, arg)
            index += 1
        elif arg == "-nb_cols":
            NB_COLS = checkNextValue(index, arg)
            index += 1
        elif arg == "-version":
            writeln("%s - version %s"%(APP_NAME, VERSION))
            # if there is a calling script, it should stop, no precompilation done,
            # only display version ant then stop, so let's return an error 
            sys.exit(1)
        elif arg == "-verbose":
            VERBOSE = True
        elif arg == "-debug":
            DEBUG = True
        elif arg == "-Wall":
            WARN_ALL = True
        elif arg == "-Wequ":
            WARN_EQU = True
        elif arg == "-Wstr":
            WARN_STR = True
        elif arg == "-Wlab":
            WARN_LAB = True
        else:
            ignored_paremeters.append(arg)
        index+=1
        if index >= len(sys.argv):
            break
    
    if WARN_ALL:
        WARN_EQU = True
        WARN_STR = True
        WARN_LAB = True

    if VERBOSE:
        writeln("-version %s"%(VERSION))
        writeln("-verbose %s"%(VERBOSE))
        writeln("-debug   %s"%(DEBUG))
        writeln("-Wall    %s"%(WARN_ALL))
        writeln("-Wequ    %s"%(WARN_EQU))
        writeln("-Wstr    %s"%(WARN_STR))
        writeln("-Wlab    %s"%(WARN_LAB))
        writeln("-ifname  %s"%(IFNAME))
        writeln("-ofname  %s"%(OFNAME))
        writeln("-dfname  %s"%(DFNAME))
        writeln("-nb_cols %s"%(NB_COLS))
        for arg in ignored_paremeters:
            writeln("ignored parameter \"%s\""%arg)
        writeln("--------------------------")

if __name__ == "__main__":

    sys.argv = ('precompile.py', '-Wall', '-ifname',\
    'monitor.asm', '-ofname', 'precompiled.asm','-dfname', 'full_prec.asm', '-nb_cols', '13') 

    parseArguments()
    
    source = SOURCE_FILE(IFNAME)
    
    if OFNAME != None:
        source.saveOutputSource(OFNAME)

    if DFNAME != None:
        source.saveDebug(DFNAME)
        
        write(source.getLabels())

